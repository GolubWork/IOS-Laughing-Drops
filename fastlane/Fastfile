org, repo             = (ENV["GITHUB_REPOSITORY"] || "").split("/")
match_org, match_repo = (ENV["MATCH_REPOSITORY"]  || "").split("/")

platform :ios do
  lane :init_ci do
    UI.message "ğŸ”§ INIT_CI: org=#{org}, repo=#{repo}, match_org=#{match_org}, match_repo=#{match_repo}"
    github_action(
      api_token:  ENV["GH_PAT"],
      org:        org,
      repo:       repo,
      match_org:  match_org,
      match_repo: match_repo,
      writable_deploy_key: true
    )
  end

lane :sync_certificates do
  UI.message "ğŸ” SYNC_CERTIFICATES: start"
  UI.message "ğŸ” API KEY ID: #{ENV["APPSTORE_KEY_ID"]}"
  UI.message "ğŸ” ISSUER ID: #{ENV["APPSTORE_ISSUER_ID"]}"

  app_store_connect_api_key(
    key_id:      ENV["APPSTORE_KEY_ID"],
    issuer_id:   ENV["APPSTORE_ISSUER_ID"],
    key_content: ENV["APPSTORE_P8"]
  )

  main_app_bundle_id = ENV["IOS_BUNDLE_ID"]
  extension_bundle_id = "#{ENV["IOS_BUNDLE_ID"]}.backgroundnotifications"
  UI.message "ğŸ” MAIN BUNDLE: #{main_app_bundle_id}"
  UI.message "ğŸ” EXT BUNDLE: #{extension_bundle_id}"

  begin
    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: [main_app_bundle_id, extension_bundle_id],
      readonly: false
    )
  rescue => e
    UI.important("âš ï¸ Failed to sync certificates, trying to recreate...")
    match(
      type: "appstore",
      storage_mode: "git",
      git_url: "git@github.com:#{match_org}/#{match_repo}.git",
      app_identifier: [main_app_bundle_id, extension_bundle_id],
      readonly: false,
      force_for_new_devices: true
    )
  end

  UI.message "ğŸ” SYNC_CERTIFICATES: done"
end


  lane :build do
    UI.message "ğŸš€ BUILD STARTED"
    setup_ci

    UI.message "ğŸ”§ Calling sync_certificates"
    sync_certificates

    UI.message "ğŸ“‚ Running ls -la"
    sh("ls -la")

    UI.message "ğŸ“¦ Running Cocoapods"
    cocoapods(clean_install: true)

    UI.message "ğŸ” Parsing ENV for paths"
    scheme          = (ENV["IOS_SCHEME"] || ENV["PROJECT_NAME"]).to_s.strip
    workspace_input = (ENV["XCODE_WORKSPACE"] || "").to_s.strip
    project_input   = (ENV["XCODE_PROJECT"]   || "").to_s.strip
    project_input   = "#{ENV["PROJECT_NAME"]}.xcodeproj" if project_input.empty? && !ENV["PROJECT_NAME"].to_s.empty?

    UI.message "ğŸ” scheme=#{scheme}"
    UI.message "ğŸ” workspace_input=#{workspace_input}"
    UI.message "ğŸ” project_input=#{project_input}"

    repo_root = File.expand_path("..", __dir__)
    UI.message "ğŸ“ repo_root=#{repo_root}"

    workspace_path = workspace_input.empty? ? nil : File.expand_path(workspace_input, repo_root)
    project_path   = project_input.empty?   ? nil : File.expand_path(project_input,   repo_root)

    UI.message "ğŸ§­ Calculated workspace_path=#{workspace_path}"
    UI.message "ğŸ§­ Calculated project_path=#{project_path}"

    if workspace_path.nil? && project_path.nil?
      UI.message "ğŸ” Searching for workspace/project in repo_root"
      found_ws = Dir[File.join(repo_root, "*.xcworkspace")].first
      found_pr = Dir[File.join(repo_root, "*.xcodeproj")].first
      UI.message "ğŸ” found_ws=#{found_ws}"
      UI.message "ğŸ” found_pr=#{found_pr}"
      workspace_path = found_ws if found_ws
      project_path   = found_pr if found_pr
    end

    UI.message "ğŸ“Œ Final workspace_path=#{workspace_path}"
    UI.message "ğŸ“Œ Final project_path=#{project_path}"

    UI.user_error!("âŒ ĞĞµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ workspace Ğ¸Ğ»Ğ¸ project") if workspace_path.nil? && project_path.nil?
    UI.user_error!("âŒ ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ° ÑÑ…ĞµĞ¼Ğ°") if scheme.empty?

    UI.message "ğŸ“‚ Using scheme: #{scheme}"
    UI.message "ğŸ“‚ Using workspace: #{workspace_path}" if workspace_path
    UI.message "ğŸ“‚ Using project: #{project_path}" if project_path

    # ==== Ğ°Ğ²Ñ‚Ğ¾Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚ CFBundleVersion ====
    UI.message "ğŸ§® Auto-increment CFBundleVersion start"
    main_bundle = ENV["IOS_BUNDLE_ID"]
    UI.message "ğŸ§® main_bundle=#{main_bundle}"

    api_key_hash = {
      key_id: ENV["APPSTORE_KEY_ID"],
      issuer_id: ENV["APPSTORE_ISSUER_ID"],
      key_content: ENV["APPSTORE_P8"]
    }

    latest_store_build = (
      begin
        UI.message "ğŸ§® Requesting App Store build number..."
        app_store_build_number(app_identifier: main_bundle, api_key: api_key_hash)
      rescue => e
        UI.message "âš ï¸ Failed to fetch store build number: #{e}"
        0
      end
    ).to_i

    ci_build   = ENV["BUILD_NUMBER"].to_i
    next_build = [latest_store_build + 1, ci_build, 1].max

    UI.message "ğŸ§® latest_store_build=#{latest_store_build}"
    UI.message "ğŸ§® ci_build=#{ci_build}"
    UI.message "ğŸ§® next_build=#{next_build}"

    UI.message "ğŸ§® Updating Info.plist and xcodeproj"
    auto_xcodeproj = project_path || Dir[File.join(repo_root, "*.xcodeproj")].first
    UI.message "ğŸ§® auto_xcodeproj=#{auto_xcodeproj}"

    main_info_plist = Dir[File.join(repo_root, "LaughingDrops", "LaughingDrops", "GoogleService-Info.plist")].first
    UI.message "ğŸ§® main_info_plist=#{main_info_plist}"

    if auto_xcodeproj && File.exist?(auto_xcodeproj)
      UI.message "ğŸ§® increment_build_number -> #{next_build}"
      increment_build_number(xcodeproj: auto_xcodeproj, build_number: next_build)
      if main_info_plist && File.exist?(main_info_plist)
        UI.message "ğŸ§® updating main_info_plist CFBundleVersion"
        set_info_plist_value(path: main_info_plist, key: "CFBundleVersion", value: next_build.to_s)
      end
    end

    ext_info_plist = Dir[File.join(repo_root, "backgroundnotifications", "**/GoogleService-Info.plist")].first
    UI.message "ğŸ§® ext_info_plist=#{ext_info_plist}"

    if ext_info_plist && File.exist?(ext_info_plist)
      UI.message "ğŸ§® updating ext_info_plist CFBundleVersion"
      set_info_plist_value(path: ext_info_plist, key: "CFBundleVersion", value: next_build.to_s)
    end

    # ==== ĞºĞ¾Ğ½ĞµÑ† Ğ°Ğ²Ñ‚Ğ¾Ğ¸Ğ½ĞºÑ€ĞµĞ¼ĞµĞ½Ñ‚Ğ° ====

    UI.message "ğŸ” Preparing code signing"
    ext_bundle   = "#{main_bundle}.backgroundnotifications"
    main_team_id = ENV["sigh_#{main_bundle}_appstore_team-id"]
    main_profile = ENV["sigh_#{main_bundle}_appstore_profile-name"]
    ext_profile  = ENV["sigh_#{ext_bundle}_appstore_profile-name"]

    UI.message "ğŸ” main_team_id=#{main_team_id}"
    UI.message "ğŸ” main_profile=#{main_profile}"
    UI.message "ğŸ” ext_profile=#{ext_profile}"

    main_target  = ENV["IOS_MAIN_TARGET"].to_s.empty? ? scheme : ENV["IOS_MAIN_TARGET"]
    notif_target = ENV["IOS_NOTIF_TARGET"].to_s.empty? ? "backgroundnotifications" : ENV["IOS_NOTIF_TARGET"]

    UI.message "ğŸ¯ main_target=#{main_target}"
    UI.message "ğŸ¯ notif_target=#{notif_target}"

    UI.message "ğŸ”§ Updating code signing settings"
    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: main_team_id,
      code_sign_identity: "Apple Distribution",
      path: workspace_path,
      targets: main_target,
      profile_name: main_profile
    )

    update_code_signing_settings(
      use_automatic_signing: false,
      team_id: main_team_id,
      code_sign_identity: "Apple Distribution",
      path: workspace_path,
      targets: notif_target,
      profile_name: ext_profile
    )

    provisioning_profiles = {}
    provisioning_profiles[main_bundle] = main_profile
    provisioning_profiles[ext_bundle]  = ext_profile

    UI.message "ğŸ“¦ provisioningProfiles=#{provisioning_profiles}"

    ipa_output_dir = File.join(repo_root, "build/iOS/ipa_out")
    UI.message "ğŸ“¦ ipa_output_dir=#{ipa_output_dir}"

    UI.message "ğŸ” Searching for .xcworkspace explicitly"
    workspace_path = Dir[File.join(repo_root, "*.xcworkspace")].first
    UI.message "ğŸ“‚ FINAL workspace_path=#{workspace_path}"
    
sh("echo 'ğŸ“ REPO ROOT:'")
sh("echo #{repo_root}")
sh("echo 'ğŸ“ WORKSPACE IN REPO ROOT:'")
sh("ls -la #{repo_root}")

sh("echo 'ğŸ“ SEARCH *.xcworkspace IN REPO ROOT:'")
sh("ls #{File.join(repo_root, '*.xcworkspace')} || true")

sh("echo 'ğŸ“ SEARCH xcschemes:'")
sh("find #{repo_root} -name '*.xcscheme' || true")

sh("echo 'ğŸ“ FULL REPO STRUCTURE:'")
sh("find /Users/runner/work/IOS-Laughing-Drops -maxdepth 4 -type d -print")
sh("echo 'ğŸ” XCODE PROJECTS:'")
sh("find /Users/runner/work/IOS-Laughing-Drops -name '*.xcodeproj' || true")
sh("echo 'ğŸ” XCWORKSPACE:'")
sh("find /Users/runner/work/IOS-Laughing-Drops -name '*.xcworkspace' || true")


sh("echo 'ğŸ” Search .xcodeproj:'")
sh("find /Users/runner/work/IOS-Laughing-Drops/IOS-Laughing-Drops -name '*.xcodeproj' || true")

sh("echo 'ğŸ” Search Podfile:'")
sh("find /Users/runner/work/IOS-Laughing-Drops/IOS-Laughing-Drops -name 'Podfile' || true")


    UI.message "ğŸ—ï¸ Starting build_app..."
    build_app(
      workspace: workspace_path,
      scheme: "LaughingDrops",
      configuration: "Release",
      clean: true
    )

    UI.message "ğŸ”‘ Setting up ASC API key again before upload"
    app_store_connect_api_key(
      key_id:      ENV["APPSTORE_KEY_ID"],
      issuer_id:   ENV["APPSTORE_ISSUER_ID"],
      key_content: ENV["APPSTORE_P8"]
    )

    ipa_path = Dir[File.join(ipa_output_dir, "*.ipa")].first
    UI.message "ğŸ“¦ ipa_path=#{ipa_path}"
    UI.user_error!("âŒ IPA Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½!") if ipa_path.nil?

    if ENV["UPLOAD_TO_TESTFLIGHT"] == "1" || ENV["UPLOAD_CHANNEL"] == "beta"
      UI.message "ğŸš€ Uploading to TestFlight"
      upload_to_testflight(
        ipa: ipa_path,
        skip_waiting_for_build_processing: true,
        changelog: (ENV["CHANGELOG"] || "Auto-upload from CI")
      )
    else
      UI.message "ğŸš€ Uploading to App Store"
      upload_to_app_store(
        ipa: ipa_path,
        submit_for_review: false,
        automatic_release: false,
        force: true,
        skip_screenshots: true,
        skip_metadata: true,
        run_precheck_before_submit: false,
        app_identifier: ENV["IOS_BUNDLE_ID"]
      )
    end

    UI.success("ğŸ‰ Ğ‘Ğ¸Ğ»Ğ´ Ğ·Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½ Ğ² App Store Connect!")
  end
end
